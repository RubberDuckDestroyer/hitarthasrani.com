{"componentChunkName":"component---src-templates-blog-post-js","path":"/aws-devax-blackbelt/day2/","result":{"data":{"site":{"siteMetadata":{"title":"Hitarth Asrani","author":"Hitarth Asrani"}},"markdownRemark":{"id":"d34da116-2dc4-5f5e-ba33-6f2d13367a40","excerpt":"Ployglot Persistence with Multiple Data Storage In Microservices\nSeparate Database for each service If use same database\nThen Locked Release Lifecycle\nThen not…","html":"<h2>Ployglot Persistence with Multiple Data Storage</h2>\n<p>In Microservices\nSeparate Database for each service</p>\n<p>If use same database\nThen Locked Release Lifecycle\nThen not independent scaling\nThen not right tech choice</p>\n<p>— DynamoDb\nDevs Try Projecting Joins on DDB\nTreating like SQL DB\nHuge No No</p>\n<p>AWS Has many DB Options\nOne for each\nRelational and Non Relational</p>\n<p>Most Common Use Cases\nRelational — Aurora, RDS\nKey value - DynamoDB</p>\n<p>Think Relational DB\nDelay Decision Time\nDelay Calling Pattern\nAt Runtime.</p>\n<p>“Not All Data is Relational”</p>\n<p>When Data Needed by other Microservices,\nShare Data using CQRS and Streams.</p>\n<h2>Moving to NoSQL w/ DynamoDB</h2>\n<p>NoSQL = Non Tabular DB\nThere is an “Arbitrary Schema”</p>\n<p>DDB - NoSQL Key Value Store\nFast Throughput, Low Latency\nBased on upfront design choices.</p>\n<p>Think Traditional Architecture\nAll data forced into RDBMS\nGood at OLAP (Analytics)\nBut bad at OLTP (Transactions)</p>\n<p>In Distributed System\nNeed single source of truth\nBut multiple copies of data\nAre OK</p>\n<p>SQL Optimised for Storage\nNOSQL Optimised for Compute\nSQL Scales Vertically\nNoSQL scales horizontally</p>\n<p>In DynamoDB\nImportant to Understand Physical Constraints</p>\n<p>Partition Key determines the Hashing Algorithm (unordered)\nSort Key can be provided\nPartition Key + Sort  = Composite Key</p>\n<p>In Composite Key\nPartition Key can be same\nSort must be unique\nData Hashed based on Composite key</p>\n<p>Design for cloud means\nThink Differently</p>\n<p>Use Indexes instead of Scan\nOr when multiple PK Data required\nLSI - Local Secondary Indexes\nGSI - Global Secondary Indexes</p>\n<p>When LSI\nAlternate Sort Key Attribute\nIndex Local to Partition key\nHighly consistent by Size Limitation</p>\n<p>LSI Defined Upfront\nIs like additional Sort key inside Table</p>\n<p>10GB Max per PK\nLSI Limits Range keys\neg Sort by UserId(PK), Date (SK), Name (Index)</p>\n<p>When GSI\nAllow you to have Alternate PK &#x26;/Or SK\nIndex across all PKs\nNo Size limit but is eventual consistent</p>\n<p>When GSI Defined\nMust Define RCUs and WCUs\nMore flexibility</p>\n<p>GSI Example\nNaive Approach = Scan + Filter. (Full Data scan still done)\nPro Approach = Query w/ PK  + Index(Filter) + Limit</p>\n<p>Under the covers\nGSI Is Additional Table\nUp to 5 GSIs\nUpdated Async</p>\n<p>When GSI and less write capacity\nDB Throttling Occurs</p>\n<p>write and immidiate read\nIndex may not update</p>\n<p>Decision to choose index\nLSI Can be modeled as GSI\nLSI Is cheaper</p>\n<p>If Data Size > 10Gigs\nIf eventual consistency\nUse GSI</p>\n<h3>Throughput</h3>\n<p>RCU - 4kb\nWCU - 1kb\nTPC = RCU/3000 + WCU/1000 (By Capacity)\nTPS  = Total Size /10 Gigs (By Size)\nTotal partitions = CEIL (Max(Capacity, Size))</p>\n<p>Throttling = TP > TP Per Partition\nSeen in\nLarge Items/ Hotkeys\nNon uniform workloads</p>\n<h3>Read Types</h3>\n<p>Strong Read - Wait for Partitions to Sync\nEventually Consistent Read - Any partition that responds first. Cheaper, 50% Capacity</p>\n<h2>Data Modelling</h2>\n<p>Think upfront about access patterns. Event Storming shows data flow</p>\n<p>Designing for DDB:</p>\n<ul>\n<li>Define ERD</li>\n<li>Identify Access patterns</li>\n<li>Design Indexes aroudn access patterns</li>\n</ul>\n<p>When DDB\nMultiple Entities in Same DB</p>\n<p>Forget RDB Shit:</p>\n<ul>\n<li>Normalization</li>\n<li>Joins</li>\n<li>Single entity in DB</li>\n</ul>\n<h3>Example: Ecommerce</h3>\n<h4>ERD</h4>\n<p>Users,          Orders,\nUserAddress,    OrderItems</p>\n<h4>Defien Access Patterns</h4>\n<ul>\n<li>Get User Profile</li>\n<li>Get orders for user</li>\n<li>Get Single order and see order items</li>\n<li>Get order status</li>\n<li>Get open Orders</li>\n</ul>\n<h4>Design PK and SK</h4>\n<p>Key\nPK (User#xxxx)       - | For user xxxx,\nSK (#PROFILE#xxxx)   - | Profile hash gets profile by adding decorator <code class=\"language-text\">#PROFILE#</code>\nAttributes\nUseranem\nFullname\nEmail\nCreatedAt\nAddress</p>\n<h3>One To many relationships</h3>\n<ul>\n<li>Attribute to list or map</li>\n<li>PK + Query</li>\n<li>Secondary Index + Query</li>\n</ul>\n<p>In this case\nStore UserAddress Blob\nIf lookup needed, use JSON</p>\n<p>Users to Orders\nOne to Many\nCreate Sort Key and Trees with Order Hash\nSo we can have multiple order hash\nwith unique order ID</p>\n<p>Now two sort keys\nProfile and Order</p>\n<p>Key\nPK (User#xxxx)\nSK (##ORder##xxxx)\nAttributes (Order)\nUseranem\nFullname\n|OrderId|\nCreatedAt\nAddress</p>\n<p>Key\nPK (User#xxxx)\nSK (#Profile#xxxx)\nAttributes (Order)\nUseranem\nFullname\n|Email|\nCreatedAt\nAddress</p>\n<h3>Many To Many relationships</h3>\n<p>Use Inverted Index\nComposite PK But Sort Key and PK Flipped\nThen used as GSI</p>\n<p>Cannot get orders and order items in one query\nBut Inverted Index can solve</p>\n<p>Consider PK User and SK Order\nGSI Order + User\nGSI Profile + User\nThen Using GSI\nGet Order + User Profile</p>\n<h3>DDB Features</h3>\n<p>Local instance available (Blog Topics?)\nNoSQL Workbench available (Blog topics?)</p>\n<h2>Design Patterns</h2>\n<h3>DDB Data Streams</h3>\n<p>Call when CRUD Operation happens and trigger lambda?\nCQRS to separate reads and writes</p>\n<h3>Sharding write heavy PKs</h3>\n<p>eg Real Time voting.</p>\n<p>Consider Write capacity exhausted\nInstead table with adaptive capacity\nUse Write Sharding</p>\n<p>Shard by adding to PK\nSomething arbitrary <em>but deterministic</em>\nThen <code class=\"language-text\">Scatter-Gather</code> to\nread aggrefate result</p>\n<h3>Read Heavy Partitions</h3>\n<p>Everyone Reads partitions\nHot partition therefore high throughput\nUse Caching instead\nbut will be managed</p>\n<p>or DAX (DDB Accelarator) — DDB Accelerator (DAX)\nfor managed caching\nDAX write through cache</p>\n<p>FOR DAX</p>\n<p>Can Write through\ncache then write</p>\n<p>Can Write around\nWrite then cache</p>\n<p>On Code end\nRemove client and add cache.</p>\n<h2>Splitting Monolith DB</h2>\n<h3>Pattern Database Wrapping Service</h3>\n<p>Introduce service to “wrap” database\nUsing Strangler Pattern</p>\n<h3>Pattern Database as a Service Interface</h3>\n<p>For Read only queries\nUse CQRS\nDifferent path for read\nDIfferent path for write\nConsumer starts accessing “Direct” API</p>\n<p>Pattern changing data ownership\nMonolith depends on service API\ninstead of Database or Direct API</p>\n<h3>Pattern Synchronisation</h3>\n<p>How to sync data</p>\n<p>Do CDC (Change Data Capture)\nNew Service Reads\nfrom monolith DB changes\nHandle eventual consistency\nBut not the best approach</p>\n<p>Otherwise have monolith\nwrite to old db\nand write to new db\nBut Dual Write</p>\n<p>Do Event Driven Sync\nMonolith writes to DB\nDB Writes to Queue\nAgent Dequeues message\nupdates new db\nNew Service Reads from own DB\nWhich Single Source Truth</p>\n<p>Avoiding 2PC in Distributed transactions\nUse SAGA Pattern Instead</p>\n<h3>SAGA Pattern</h3>\n<p>SAGA Pattern\nUses eventual consistency\nHandles transactions across\nmultiple data store</p>\n<p>Two flavours of SAGA\nOrchestration and Choreography\nOrchestration inside aggregate\nChoreography inside bound context</p>\n<p>In SAGA Pattern\nNo mater service\nBut rather multiple service\nOrchestrated with rollback option</p>\n<p>In Choreography\nMessage goes to Bus/ Message Broker\nMultiple Services consume Bus\nIf problem, side effect will need rollback</p>\n<p>In Orchestration\nUse orchestrator instead\nfor single point of control</p>\n<p>Difference,\nCorreography - each components need to be aware of each other\norchestration - Orchestrator need to be aware of everyone’s states</p>\n<p>Simple workflows need choreography\nTherefore less participants\nbut difficult to test in isolation</p>\n<p>Orchestration for complex workflows\nTherefore more participants\nbut single point of failure\nAddressed by Step Functions</p>\n<p>Sagas not perfect\nConsider semantic locking countermeasure (out of order calls)\nBeware Dirty Reads\nGroup transactions fall behind pivot transactions\nCOunteract lost updates\nConsider Conditional writes or atomic transactions in DDB</p>\n<h2>Distributed complexity &#x26; AWS Step Functions</h2>\n<p>Step Functions for Key Behaviours\nSequence Fucntions\nParallel processing\nRetry\nConditions\nTry Catch\nSegments</p>\n<p>Could try function chaining\nbut tight coupling</p>\n<p>Could try central coordination\nUsing Database or queues\nBut still need elements\nKnow what to do on failure</p>\n<p>Instead need orchestrator\nwith must have\nObservaBLT</p>\n<p>— AWS Step Functions</p>\n<h2>App Integration Patterns</h2>\n<p>Message Exchange\nCan one way - no response, fire and forget. Use Queue\nCan REquest-Response - Rather than rest, use two message change. Eventual consistency. Will need Correlation Id</p>\n<p>Can Point to point - queue with multiple endpoints but only one receiver. Flatten peak loads</p>\n<p>Can PubSub - Multiple Subscribers</p>\n<p>Can chain topics to queues - Fan out and receiver scale out at same time</p>\n<p>Can Scatter-gather\nNot sure which subscriber will be right/ first response\nor paraller processing\nFan out then fan in\nwith aggregator at end</p>\n<p>Can have timed result\nfor tight SLAs</p>\n<p>Can also add callback\nWebsockets over MQTT (IoT Message Broker) (Blog Topic)\nOr Use AWS AppSync\nOr API Gateway\nTherefore remove polling\nwhich DDOS yourself</p>\n<p>Lab Options</p>\n<ul>\n<li>AwesomePets - SAGA Pattern with callback to handle transactions</li>\n<li>WildRydes - Foundation with bonus labs</li>\n</ul>","frontmatter":{"title":"AWS APN DevAx Black Belt Day 2","date":"Invalid date","description":"AWS DevAx Black Belt Day 2."}}},"pageContext":{"slug":"/aws-devax-blackbelt/day2/","previous":{"fields":{"slug":"/aws-iam-policy-simulator/"},"frontmatter":{"title":"Using AWS IAM Policy Simulator to debug IAM Policy Issues"}},"next":{"fields":{"slug":"/aws-devax-blackbelt/"},"frontmatter":{"title":"AWS APN DevAx Black Belt Day 1"}}}},"staticQueryHashes":["4123550546","63159454"]}