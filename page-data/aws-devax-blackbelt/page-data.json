{"componentChunkName":"component---src-templates-blog-post-js","path":"/aws-devax-blackbelt/","result":{"data":{"site":{"siteMetadata":{"title":"Hitarth Asrani","author":"Hitarth Asrani"}},"markdownRemark":{"id":"5b772e91-2e09-5ffc-92bb-04459082a46d","excerpt":"BlackBelt is a program to build specialised capabilities in AWS Partners APJ - Dev Accelerator. 1st cohort (AUNZ)\nIf the pilot is successful this will be…","html":"<p>BlackBelt is a program to build specialised capabilities in AWS Partners</p>\n<p>APJ - Dev Accelerator. 1st cohort (AUNZ)\nIf the pilot is successful this will be launched at reinvent 2022\nLet them know about other specialised capabilities.</p>\n<p>The program will:</p>\n<ul>\n<li>Help partners in mdoern app dev</li>\n<li>Build partner network</li>\n<li>Hands on experience with pre sales capabilities. Present an oral defence, against a customer panel.</li>\n</ul>\n<p>AWS DevAx Intro - Adam Larter (Head of DevAx APJ).</p>\n<h2>Intros</h2>\n<ul>\n<li>Andrew Cowan</li>\n<li>Bojan Zivic</li>\n<li>Praveen Kumar Patidar</li>\n</ul>\n<h3>The Course</h3>\n<p>Modernization - patterns and architectures, Containerization, distributed systems.</p>\n<ul>\n<li>Moderinzation of monoliths to microservices with hands on labs</li>\n<li>Eventstorming workshop on friday</li>\n<li>When dealing with customers use situational awareness</li>\n<li>Better articulate to customer</li>\n</ul>\n<p>What do modern devs need to know?\nCloud dev concepts, Async and decoupled apps, moving from mono to micro methodologies,\ndistributed systems, Messaging and event, ObservaBLT, CICD, Decoupling, CQRS, Event Sourcing AuthN &#x26; AuthZ</p>\n<p>Customers can be Day 0 (ie what is cloud)\nCloud is generally an infra team thing, generaly not a dev thing.\nrun a discovery session with customers.</p>\n<p>Success Factors for Moderinizing dev teams.\nTelling customer to do ABC is not going to work. We need DevOps but without business understanding and business change required, adoption does not go through.</p>\n<p>(LZ = foundational architecture.)\nConsumers have a great stall after moving a couple of workloads -  becuase generally devs are not taken through journey. Ie Infra Lead instead of Dev laed approach.</p>\n<p>Devs need to think in terms of distributed systems.\n35% apps cloud native. Partners and help needed.</p>\n<h3>Architectureal Patterns</h3>\n<ul>\n<li>Shrink the scope (MVP) Dev thinking - treat infra as object oriented.</li>\n<li>When change impact is small, release velocity can increase. Reduced cognitive load. Small infra to do small tasks.</li>\n<li>APIs are front services of Microservices (Encapsulation, Isolation</li>\n<li>Event Driven = Decoupling. Sync to Async. Devs need to know about costs as well</li>\n<li>Devs need to understand microservices patterns.</li>\n<li>Team topologies make a difference. This is different for a monolithic architecture. Customers need to rethink team structure. Devs need to have ownership and should be able to go forward. <strong>READ MORE ABOUT THIS</strong>\neg - Service Team, enabling team (allows Just In Time/ DevOps), Subsystem team; Specialist team (Subject Matter Experts), Platform Team (Devs can reducr cognitive load when new infra is needed while following “What good looks like”, following the scaffolding and not starting from scratch).</li>\n<li>Discourage silos in the organization. Team manages all aspects including testing. Devs have full ownership.</li>\n</ul>\n<p>Event carried state transfer -  read. ie do not throw 10 Mb of data around.</p>\n<h3>When dealing with customer enablement</h3>\n<p>Customer Discovery - Find current, to be architecture and where the holes lie.</p>\n<ul>\n<li>general cloud concepts</li>\n<li>Implement Async and decouplled shit</li>\n<li>Automation (CICD)</li>\n<li>Authentication</li>\n</ul>\n<p>assumptions - condensed version. ie you know CDK and infra.\nSkip Lift and Shift.\nRecommended Reading - Monolith to Microservices, Building Microservices, Domain Driven Design.</p>\n<h2>Module 1</h2>\n<p>eventbox.dev/survey/FGSKVOF</p>\n<h3>Distributed Systems</h3>\n<p>People Say the following -\nDecentralise componenets\nRemoving memory call, using multiple languages.\nResilience\nPolyglot - tech stack and data model\nharder to test from system perspective.</p>\n<p>most important - <strong>Deal with independent fault domains</strong>\nWhen breaking monolith to micro, since there is no machine call, you need to keep an eye on network. This is not deterministic and assuming that this is deterministic is heading towards failure.</p>\n<p>Multiple failure modes are introduced. it may fail in bizzare ways. ie call fails to send request/ A sends request but B does not receive it.</p>\n<p>Fuzzy situation to deal with. You have to think differently. Handle exceptions, meaningful messages. Patterns need to think about this.</p>\n<p>Difference-</p>\n<ul>\n<li>Independent/ Isolated fault domains</li>\n<li>Latency and reliability</li>\n<li>State management</li>\n<li>Ownership and diversity</li>\n<li>Eventual consistency</li>\n<li>Transaction handling</li>\n</ul>\n<p>Fallacies:</p>\n<ul>\n<li>Network is reliable, homogeneous and secure</li>\n<li>0 latency</li>\n<li>Bandwidth is infinite</li>\n<li>Topology does not change</li>\n<li>Single Admin</li>\n<li>Everyone trusts each other.</li>\n</ul>\n<p>Exmaple Monolith</p>\n<ul>\n<li>Single vertically scaled server</li>\n<li>One change means an entire app needs to be tested.</li>\n</ul>\n<p>Monolith: UI, Middle tier and data all happens in one box. DB might be in a separate box but everything is self contained and shared.</p>\n<p>Travel Buddy Example - JSP App (HTML with embedded tags)</p>\n<ul>\n<li>JSP app with two data fields (XML) and an single HTTP page. REST interface.</li>\n<li>On a code level - html data shown during render time.</li>\n<li>Image makes single call with message in query string. Not really an API Call.</li>\n<li>NOTE: data is fairly well separated. Data access objects are also well separated. This could be worse in older monoliths w/ spaghetti code.</li>\n</ul>\n<p>First Step - Lift and Shift </p>\n<p>using elastic beanstalk.\nCan setup CICD pipeline.</p>\n<p>using ECS\nCan also conver the mono to an ECS Cluster taking docker task defn and pushed it to cluster with load balancer and listeners hidden behind an endpoint.</p>\n<p>Using EC2 - deploy on EC2.</p>\n<p>This only makes it managed and easy to scale horizontally. Regardless of how it is running you can think about modernization.</p>\n<p>Fundamental Outcomes for modernization - take from customer.</p>\n<ul>\n<li>Move away from vertical scaling</li>\n<li>Technically, we need to move away from large blast radius as well.</li>\n<li>Monolithic tech stack.</li>\n<li>make independent changes for velocity.</li>\n</ul>\n<p>Use 7R’s (Put link)</p>\n<p>We want high cohesion and decoupling.\nSometimes, there is nothing wrong with a monolith. It could be a “Modular monolith”.\nWhen it was made, it followed best practices. </p>\n<p>We must also follow SOLID Principles\n“you call the contract and do not worry about what is behind the scenes”</p>\n<p>Single vs Modular monolith\nIf it is a single monlith - move it towards a modular monolith. Low risk and no major change.\nOn the data layer, split it out if you can. Modular monolith is a valid arch pattern.</p>\n<p>When microservices are not valid</p>\n<ul>\n<li>Unclear Domain; Wrong service boundaries can be expensive</li>\n<li>Startups; they need scale and experimentation on a market fit.</li>\n<li>COTS Software: No access to codebase to make real changes</li>\n<li>Not having a good reason: Accepting because “they did it”</li>\n</ul>\n<p>Scenarios for moving to microservices</p>\n<p>Business Case to</p>\n<ul>\n<li>Go Faster and get enw features</li>\n<li>Be more stable</li>\n<li>better quality</li>\n<li>Cheaper, reduced Total Cost of ownership.</li>\n</ul>\n<h3>Coupling Types</h3>\n<h3>Microservices</h3>\n<p>“There is no precise defination of the arch style”\nBut they must have characteristics around business capability, automation and decentralisation, intelligence endpoints, compensation via services.</p>\n<p>ONE COMPONENT MUST DO ONE THING\nThink about reusability. Tech stack for two actions may be completely different.\nMicoServices must be broken down to as granular as possible.\nNot 5000 lines of code. how much is it doing? Few lines of code for quick engineering\nOwn tehir statae and do not share\nManaged by the team who built them\nIndependent release cycles\nFreedom to use the right tech stack</p>\n<p>Microservices is an approach for a collection of small isolated services</p>\n<p>Serverless is a compute choice. these choices are made when we chop the monolith down. Talk to customer about data flow and other fracture points.</p>\n<p>Key Takeaways</p>\n<ul>\n<li>Independently deployable, work together modelled around a business domain.</li>\n<li>Communicate via networks</li>\n<li>DBs are hidden</li>\n</ul>\n<p>FAQ:</p>\n<ul>\n<li>Just Service Oriented Architecture? -  NO</li>\n<li>How is it micro? How many is too many? - It comes down to the cognitive load.</li>\n<li>Just like Object Oriented Code?</li>\n<li>not just a tech change!</li>\n</ul>\n<h3>Identifying fracture planes</h3>\n<h3>Tools for Domain modelling</h3>\n<h3>Team structure and conways law</h3>\n<p>Constrained design systems = constrained communication\nMonolith = 3 tier architecture. Changes cannot be isolated.\nMicro = Changes are behind an API and do not affect it.</p>\n<h3>Decomposing the monolith</h3>\n<p>Find natural seams or fracture points.</p>\n<p>Book -  The art of scalability. Scalability</p>\n<ul>\n<li>On X Axis (Elastic Beanstalk or ECS Cluster)</li>\n<li>On Z Axis - Run multiple copies with intelligence on LB. Data partitioning.</li>\n<li>On Y Axis, Functional Decomposition. Scale by splitting different things. THIS IS THE BENEFIT. Each component is implemented separately.</li>\n</ul>\n<p>Identifying fracture planes:</p>\n<ul>\n<li>Change to single service</li>\n<li>Deploy changes separately</li>\n<li>Right Sizing</li>\n<li>Scaling under load\n{CHECK AGAIN FOR MISSING POINT}</li>\n</ul>\n<p>Domain Driven Design:</p>\n<ul>\n<li>Identify bounded contexts. ie Customer in a Sales context is different when compared to Customer in Support context.\nBoundary = Specific responsibility enforced by explicit boundaries.</li>\n</ul>\n<p>DDD and Bounded Context.</p>\n<ul>\n<li>Encapsulate single domain ie Sales or support</li>\n<li>Defines integration points with other domains.</li>\n<li>Align well with microservices</li>\n<li>Microservices must be well defined bounded context.</li>\n</ul>\n<p>Look for seams, natural divisions that “peel easily”. CRUD Services are a goof candidates. Look for classes w/ no dependencies apart from scaffolding</p>\n<p>Look at compliance and risk. Release and change cadence. Team location, performance isolation\nLook at tech choices and cognitive load.</p>\n<ul>\n<li>Identify Explicit boundaries</li>\n</ul>\n<h3>Patterns for moderinization using the strangling pattern</h3>\n<h3>Event Storming</h3>\n<p>Event modelling = think about system behaviour and not the system structure</p>\n<p>Event is an indicator that the system state has changed. It is immutable and has happened in the past. It has semantic intent that means something.\nIt should be lightweight.\nEvents are observed and not directed. Event publisher does not need to worry about subscribers.\nCommands are blocking calls.</p>\n<p>Event Storming is discussing the flow of events in your org and modelling that flow in an easy to understand way. Also think about future changes that could be possible.</p>\n<p>Event flow -  understand what happens to the system over time.\nPolicy - When A happens do B. (Business Rules)\nCommands - Imperatives/ Create or Update X.\nAggregates - Bunch of Flows, policies and commands built around a domain. One microservice = one or more aggregates.</p>\n<p>Think of objects in system with bound lifecycle.\nBlocking calls =  REST API. Non Blocking = Queues.</p>\n<p>Bounded Contexts - One or more aggregates made by a lifecycle policies. Tight coupling inside adregates and loose between aggregates.</p>\n<p>Approaches to decoupling:</p>\n<p>Options: Change the model, OR upload v2 of same interface.</p>\n<p>WE WANT HIGH COHESION\nWE WANT LOW COUPLING. (ie one change affects another)</p>\n<p>Types of coupling</p>\n<p>Implementation</p>\n<p>Temporal</p>\n<p>Deployment: You might need to Update module A when Module B is updated</p>\n<p>Domain Coupling: Only get info needed by domain/business process and remove improper use of payload.</p>\n<p>When Coupled:\nConsider Merging\nConsider bounded contexts.\nConsider orchestration (of changes; using step functions)</p>\n<p>Consider Shared Database\nDatabase per service instead.</p>\n<p>Consider Sync vs Async</p>\n<p>When Sync\nThink Reliability\nThink Temporal Coupling\nUse Service Discovery (Registery) Service — AWS Cloud Map.\nCircuit Breaker\n- When error; use default response for downstream — AppMesh\nUse Mssage / Event Driven Architecture\nHelp Use Async Architecture instead. (Choreography Pattern)</p>\n<p>— SQS SNS EventBridge Kinesis Kafka</p>\n<p>Think ACID\nThink Async and DB/service\nCompensate w/ SAGA Pattern</p>\n<h2>Patterns in moving to a distributed system architecture</h2>\n<p>Look, Patterns!\nStrangler Fig, Anti Corruptuin Layer (ACL)\nFacade Pattern</p>\n<p>“If you do a rewrite of ‘x’ you will guarantee only ‘x’”</p>\n<p>Is Facade\nFront Facing masking\nComplex Underlying/Structural Code</p>\n<p>Is Adapter\nSimilar to ACL\nAdding Adapter, changing model\nusing wrapper, without modifying source code.</p>\n<h2>Strangling the monolith</h2>\n<p>Strangler Pattern\nLike Parasite, will kill old infrastructure\nTake monolith parts bit by bit\nAnd Break Off!\nReduce Risk</p>\n<p>Pattern Example\nCreate New Microservice\nAdd New Feature</p>\n<p>Create Microservice with ACL\nInto Old Service\nCorrupt Old Data Model\nCall Microservice Instead\nSync using Queue/Agent</p>\n<p>Add More Microservice\nUntil No one calls\nThe Backend</p>\n<h2>Migration Hub Refactor Spaces</h2>\n<p>Implememting new feed</p>\n<p>— Migration Hub Refactor Spaces\nLaunch new feaure fast (Leave and Layer)\nRefactor incrementally (Strangler Fig [Pig lol])</p>\n<p>Refactor Spaces\nManages Heavy Lifting\nCan still manage layers</p>\n<p>Create Space, Share Environment, Create App, Create Services, Add Routes</p>\n<p>Create Space, Share Environment\nMake Transit Gateway</p>\n<p>Why Shared?\nOne Account Monolith\nOne Account MicroService\nOne Account Refactor Spaces Owner</p>\n<p>Create App Means\nCreate API gateway, connect Transit Gateway\nCan connect any HTTP Enpoint\nAny account or on prem\nprovided routing</p>\n<p>Using Routing Endpoint,\nCan have root to Monolith\nCan have custom route to Microservice</p>\n<p>Monolith Isolated\nNew Functionality Added\nIs Microservices</p>\n<h2>Recommendations</h2>\n<p>Start with Simplest\nAvoid Dependencies - Monolith may depend on the microservice but not the other way around.\nOrder and prioritise migration - Hot Spots, Business Priority\nDecouple across all lyers\nBreak tight coupling\nExtract functionality not code\nMacro then micro not nano\nRespect rules\nAutomate and Observe</p>","frontmatter":{"title":"AWS APN DevAx Black Belt Day 1","date":"Invalid date","description":"AWS DevAx Black Belt Day 1."}}},"pageContext":{"slug":"/aws-devax-blackbelt/","previous":{"fields":{"slug":"/aws-devax-blackbelt/day2/"},"frontmatter":{"title":"AWS APN DevAx Black Belt Day 2"}},"next":{"fields":{"slug":"/aws-devax-blackbelt/day4/"},"frontmatter":{"title":"AWS APN DevAx Black Belt Day 4"}}}},"staticQueryHashes":["4123550546","63159454"]}